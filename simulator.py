import time
import instructions

class COMET2Simulator:
    """
    A simulator for the COMET II computer architecture.
    It executes machine code generated by a CASL II compiler.
    """
    # Constants for memory size and word representation
    MEMORY_SIZE = 65536  # 2^16 words of memory
    WORD_MAX = 65535     # Maximum value for a 16-bit unsigned word
    WORD_MIN = -32768    # Minimum value for a 16-bit signed word

    def __init__(self, debug=False):
        """Initializes the virtual machine's state."""
        self.debug = debug
        self.memory = [0] * self.MEMORY_SIZE
        
        # General Purpose Registers (GR0-GR7)
        self.gr = [0] * 8
        
        # Special Purpose Registers
        self.pr = 0  # Program Counter
        self.sp = 0  # Stack Pointer
        
        # Flag Register (FR)
        self.of = 0  # Overflow Flag
        self.sf = 0  # Sign Flag
        self.zf = 0  # Zero Flag
        
        # This dictionary maps an opcode to the function that handles it.
        self.instruction_map = {
            0x10: instructions.ld_mem,
            0x11: instructions.st,
            0x12: instructions.lad,
            0x14: instructions.ld_reg,
            0x20: instructions.adda_mem,
            0x24: instructions.adda_reg,
            # You can add more opcodes here later
        }

        self.is_running = False
        print("COMET II Simulator initialized.")

    def _reset_flags(self):
        """Resets all flags to zero."""
        self.of = 0
        self.sf = 0
        self.zf = 0

    def _update_flags(self, value):
        """Updates SF and ZF based on a value."""
        # Check for signed overflow (not fully implemented for all instructions)
        # self.of = 1 if value > 32767 or value < -32768 else 0
        
        # Update Sign Flag
        self.sf = 1 if value < 0 else 0
        
        # Update Zero Flag
        self.zf = 1 if value == 0 else 0

    def load_program(self, machine_code, start_address=0):
        """
        Loads the machine code into the simulator's memory.
        :param machine_code: A list of hexadecimal strings.
        :param start_address: The memory address to start loading the code.
        """
        print(f"\n--- Loading Program into Memory at address {start_address} ---")
        for i, code in enumerate(machine_code):
            address = start_address + i
            if address < self.MEMORY_SIZE:
                # Convert hex string to integer and store it
                self.memory[address] = int(code, 16)
            else:
                print(f"Error: Memory address {address} out of bounds.")
                return False
        
        # Set the Program Counter to the start of the program
        self.pr = start_address
        print(f"Program loaded successfully. PC set to {self.pr}.")
        return True

    def _fetch(self):
        """Fetches the word at the current Program Counter."""
        instruction_word = self.memory[self.pr]
        self.pr += 1
        return instruction_word

    def _get_effective_address(self, r, x, addr):
        """Calculates the effective address from the instruction."""
        # For now, we only handle direct addressing (x=0)
        if x == 0:
            return addr
        # If an index register is used, add its content to the address
        else:
            return addr + self.gr[x]

    # THIS IS THE NEW CODE TO USE
    def run(self):
        """Starts the execution cycle using the dispatch table."""
        self.is_running = True
        print("\n--- Starting Simulation ---")
        
        while self.is_running:
            if self.pr >= self.MEMORY_SIZE:
                print("Error: Program Counter out of bounds.")
                break

            start_pr = self.pr
            instruction_word = self._fetch()

            # Handle HALT as a special case before decoding
            if instruction_word == 0:
                instructions.halt(self, 0, 0)
                continue # Skips the rest of the loop and re-checks self.is_running

            # Decode the instruction
            full_opcode = (instruction_word >> 8) & 0xFF
            r1 = (instruction_word >> 8) & 0xF
            r2_or_x = (instruction_word >> 4) & 0xF
            
            if self.debug:
                print(f"\nPC: {start_pr:04X} | Instruction: {instruction_word:04X} | Opcode: {full_opcode:02X}")

            # --- New Execution Logic ---
            # 1. Look up the function in our map. If not found, use the 'unknown' function.
            exec_func = self.instruction_map.get(full_opcode, instructions.unknown)
            
            # 2. Call the function we found.
            # This single line replaces the entire if/elif/else block.
            # We pass 'self' so the function can access memory/registers.
            # We pass the operands for the function to use.
            # (A more advanced version would decode operands differently based on format,
            # but this works for now).
            if full_opcode in [0x14, 0x24]: # Register-to-register format
                r2 = r2_or_x
                exec_func(self, r1, r2)
            elif full_opcode in [0x10, 0x11, 0x12, 0x20]: # Memory format
                r = r1
                # For ST and LAD, the compiler encodes the register with an offset of 8
                if full_opcode in [0x11, 0x12]: 
                    r = r1 - 8
                x = r2_or_x
                exec_func(self, r, x)
            else: # Unknown instruction
                instructions.unknown(self, r1, r2_or_x)

            time.sleep(0.1)

        self.dump_state()

    def dump_state(self):
        """Prints the final state of the registers and relevant memory."""
        print("\n--- Final Machine State ---")
        for i in range(8):
            print(f"GR{i}: {self.gr[i]:<6} ({self.gr[i]:04X})")
        print("-" * 20)
        print(f"PC: {self.pr:04X}")
        print(f"FR: OF={self.of} SF={self.sf} ZF={self.zf}")
        print("-" * 20)
        print("Memory Contents (non-zero):")
        for i, val in enumerate(self.memory):
            if val != 0:
                print(f"  mem[{i:04X}]: {val:<6} ({val:04X})")


if __name__ == '__main__':
    # This is how you would use the simulator with your compiler's output.
    
    # 1. This is the machine code generated by your 'compilor.py'
    #    for the sample program.ã€€
    generated_machine_code = [
        '1010', '0005',  # LD    GR1, A
        '1412',          # LD    GR1, GR2 (Note: I've corrected the opcode from your compiler output)
        '1210', '0006',  # LAD   GR1, B
        '2010', '0006',  # ADDA  GR1, B
        '1110', '0007',  # ST    GR1, C
        '0003',          # A     DC    3
        '0005',          # B     DC    5
        '0000',          # C     DS    1 (Initialized to 0)
        '0000'           # HALT signal
    ]

    # 2. Create an instance of the simulator.
    #    Set debug=True to see step-by-step execution details.
    simulator = COMET2Simulator(debug=True)

    # 3. Load the program into the simulator's memory.
    if simulator.load_program(generated_machine_code):
        # 4. Run the simulation.
        simulator.run()
